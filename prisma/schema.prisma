// Pick'd Review Intelligence V1 - Prisma Schema
// Full production schema with all V1 features

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================
// CORE TENANCY
// ============================================================

model Organization {
  id                 String             @id @default(uuid())
  name               String
  slug               String             @unique
  subscriptionTier   SubscriptionTier   @default(STARTER)
  subscriptionStatus SubscriptionStatus @default(ACTIVE)
  settings           Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenants     Tenant[]
  users       User[]
  themes      Theme[]
  memberships Membership[]
  ruleSets    RuleSet[]

  @@index([slug])
  @@index([subscriptionStatus])
}

enum SubscriptionTier {
  STARTER
  PROFESSIONAL
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  SUSPENDED
  CANCELLED
}

// Tenant = Branch in multi-location restaurant context
model Tenant {
  id             String       @id @default(uuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  name     String
  slug     String
  address  String?
  city     String?
  region   String?
  country  String?
  timezone String  @default("Africa/Johannesburg")

  // External identifiers for review sources
  googlePlaceId        String?
  hellopeterBusinessId String?
  tripadvisorId        String?
  facebookPageId       String?

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  connectors      Connector[]
  ingestionRuns   IngestionRun[]
  reviews         Review[]
  scoreRuns       ScoreRun[]
  themeScores     ThemeScore[]
  fixScores       FixScore[]
  recommendations Recommendation[]
  tasks           Task[]
  branchAccess    BranchAccess[]

  @@unique([organizationId, slug])
  @@index([organizationId])
  @@index([organizationId, isActive])
  @@index([googlePlaceId])
}

// ============================================================
// USER & ACCESS MANAGEMENT
// ============================================================

model User {
  id             String        @id @default(uuid())
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?
  firstName     String
  lastName      String

  role         UserRole
  isPickdStaff Boolean  @default(false)
  tenantAccess String[] @default([]) // Legacy: array of tenant IDs

  image     String?
  avatarUrl String?

  isActive    Boolean   @default(true)
  lastLoginAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // Membership relations
  memberships Membership[]

  // Application relations
  createdParameterSets   ParameterSetVersion[] @relation("CreatedBy")
  activatedParameterSets ParameterSetVersion[] @relation("ActivatedBy")
  createdRuleSets        RuleSetVersion[]      @relation("RuleSetCreatedBy")
  activatedRuleSets      RuleSetVersion[]      @relation("RuleSetActivatedBy")
  triggeredScoreRuns     ScoreRun[]
  assignedTasks          Task[]                @relation("AssignedTo")
  createdTasks           Task[]                @relation("CreatedBy")
  auditLogs              AuditLog[]

  @@index([organizationId])
  @@index([email])
  @@index([isPickdStaff])
  @@index([role])
}

// Membership: User ↔ Organization ↔ Role mapping
model Membership {
  id             String       @id @default(uuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  role     MemberRole @default(MEMBER)
  isActive Boolean    @default(true)

  invitedAt  DateTime?
  acceptedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchAccess BranchAccess[]

  @@unique([userId, organizationId])
  @@index([organizationId])
  @@index([userId])
}

enum MemberRole {
  OWNER
  ADMIN
  MANAGER
  MEMBER
  VIEWER
}

// BranchAccess: Which branches/tenants a member can access
model BranchAccess {
  id           String     @id @default(uuid())
  membershipId String
  membership   Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  tenantId     String
  tenant       Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  accessLevel AccessLevel @default(READ)

  createdAt DateTime @default(now())

  @@unique([membershipId, tenantId])
  @@index([tenantId])
  @@index([membershipId])
}

enum AccessLevel {
  READ
  WRITE
  ADMIN
}

// ============================================================
// NEXTAUTH.JS MODELS
// ============================================================

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  // Pick'd Internal
  PICKD_ADMIN
  PICKD_SUPPORT
  // Restaurant Users
  OWNER
  MANAGER
  STAFF
}

// ============================================================
// CONNECTORS & INGESTION
// ============================================================

// Connector: Configuration for each review source
model Connector {
  id       String @id @default(uuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  sourceType SourceType
  name       String

  // External identifiers
  externalId     String?
  externalUrl    String?
  externalConfig Json? // Source-specific config (API keys, OAuth tokens, etc.)

  // Sync configuration
  syncFrequency SyncFrequency @default(DAILY)
  lastSyncedAt  DateTime?
  nextSyncAt    DateTime?

  // Status
  status       ConnectorStatus @default(PENDING)
  errorMessage String?
  errorCount   Int             @default(0)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ingestionRuns IngestionRun[]
  reviews       Review[]

  @@unique([tenantId, sourceType])
  @@index([tenantId])
  @@index([tenantId, status])
  @@index([status, nextSyncAt])
}

enum SourceType {
  GOOGLE
  HELLOPETER
  FACEBOOK
  TRIPADVISOR
  YELP
  ZOMATO
  OPENTABLE
  WEBSITE
  INSTAGRAM
  TWITTER
}

enum SyncFrequency {
  HOURLY
  DAILY
  WEEKLY
  MANUAL
}

enum ConnectorStatus {
  PENDING
  ACTIVE
  PAUSED
  ERROR
  DISCONNECTED
}

// IngestionRun: Track each data ingestion job
model IngestionRun {
  id          String    @id @default(uuid())
  tenantId    String
  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  connectorId String
  connector   Connector @relation(fields: [connectorId], references: [id], onDelete: Cascade)

  runType IngestionRunType @default(SCHEDULED)
  status  IngestionStatus  @default(PENDING)

  // Stats
  reviewsFetched  Int @default(0)
  reviewsCreated  Int @default(0)
  reviewsUpdated  Int @default(0)
  reviewsSkipped  Int @default(0)
  duplicatesFound Int @default(0)
  errorCount      Int @default(0)

  // Timing
  startedAt   DateTime?
  completedAt DateTime?

  // Error tracking
  errorMessage String?

  // API pagination state (for resumption)
  paginationState Json?

  createdAt DateTime @default(now())

  errors IngestionError[]

  @@index([tenantId, createdAt])
  @@index([connectorId, createdAt])
  @@index([status])
}

enum IngestionRunType {
  SCHEDULED
  MANUAL
  BACKFILL
  RETRY
}

enum IngestionStatus {
  PENDING
  RUNNING
  COMPLETED
  PARTIAL
  FAILED
}

// IngestionError: Track individual errors during ingestion
model IngestionError {
  id             String       @id @default(uuid())
  ingestionRunId String
  ingestionRun   IngestionRun @relation(fields: [ingestionRunId], references: [id], onDelete: Cascade)

  errorType    IngestionErrorType
  errorCode    String?
  errorMessage String
  context      Json? // Review data that failed, API response, etc.

  isRetryable Boolean @default(true)
  retryCount  Int     @default(0)

  createdAt DateTime @default(now())

  @@index([ingestionRunId])
  @@index([errorType])
}

enum IngestionErrorType {
  API_ERROR
  RATE_LIMIT
  AUTH_FAILURE
  PARSE_ERROR
  VALIDATION_ERROR
  DUPLICATE
  TIMEOUT
  UNKNOWN
}

// ============================================================
// REVIEWS & ANALYSIS
// ============================================================

model Review {
  id          String    @id @default(uuid())
  tenantId    String
  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  connectorId String
  connector   Connector @relation(fields: [connectorId], references: [id], onDelete: Cascade)

  externalReviewId String

  // Core data
  rating     Int? // 1-5 (optional, some sources don't have ratings)
  title      String?
  content    String
  authorName String?
  authorId   String?
  reviewDate DateTime

  // Response tracking
  responseText String?
  responseDate DateTime?
  respondedBy  String?

  // Engagement metrics (for W_engagement)
  likesCount   Int @default(0)
  repliesCount Int @default(0)
  helpfulCount Int @default(0)

  // NLP analysis
  detectedLanguage String?
  sentimentRaw     Float? // Raw sentiment before weighting

  // Quality & deduplication
  contentHash         String?
  textLength          Int?
  duplicateSimilarity Float?
  qualityFlags        String[] @default([]) // e.g., ["short", "vague", "likely_fake"]

  rawData Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviewThemes ReviewTheme[]
  reviewScores ReviewScore[]

  @@unique([connectorId, externalReviewId])
  @@index([tenantId, reviewDate])
  @@index([tenantId, reviewDate, rating])
  @@index([connectorId, reviewDate])
  @@index([contentHash])
  @@index([detectedLanguage])
}

model Theme {
  id             String        @id @default(uuid())
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  name        String
  category    ThemeCategory
  description String?
  keywords    String[]      @default([])
  color       String?
  icon        String?

  // Matching configuration
  matchingRules Json? // Advanced theme matching rules

  isSystem Boolean @default(false)
  isActive Boolean @default(true)

  sortOrder Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviewThemes    ReviewTheme[]
  themeScores     ThemeScore[]
  fixScores       FixScore[]
  recommendations Recommendation[]
  tasks           Task[]

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([isSystem])
  @@index([category])
}

enum ThemeCategory {
  SERVICE
  PRODUCT
  AMBIANCE
  VALUE
  CLEANLINESS
  LOCATION
  OTHER
}

model ReviewTheme {
  id       String @id @default(uuid())
  reviewId String
  review   Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  themeId  String
  theme    Theme  @relation(fields: [themeId], references: [id], onDelete: Cascade)

  sentiment       Sentiment
  confidenceScore Float
  excerpt         String?
  keywords        String[] @default([]) // Matched keywords

  createdAt DateTime @default(now())

  @@unique([reviewId, themeId])
  @@index([themeId])
  @@index([reviewId, sentiment])
}

enum Sentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

// ============================================================
// SCORING ENGINE (PICK'D ADMIN ONLY)
// ============================================================

model ParameterSetVersion {
  id            String  @id @default(uuid())
  versionNumber Int     @default(autoincrement())
  name          String
  description   String?

  parameters Json // See ParameterSet interface

  status      ParameterStatus @default(DRAFT)
  activatedAt DateTime?

  activatedById String?
  activatedBy   User?   @relation("ActivatedBy", fields: [activatedById], references: [id], onDelete: SetNull)
  createdById   String
  createdBy     User    @relation("CreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  scoreRuns ScoreRun[]

  @@index([status])
  @@index([activatedAt])
}

enum ParameterStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

// RuleSet: Configuration for recommendation generation
model RuleSet {
  id             String       @id @default(uuid())
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  name        String
  description String?
  category    RuleSetCategory

  isSystem Boolean @default(false)
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  versions RuleSetVersion[]

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([isSystem])
  @@index([category])
}

enum RuleSetCategory {
  RECOMMENDATION
  ALERT
  SCORING
  AUTOMATION
}

model RuleSetVersion {
  id            String  @id @default(uuid())
  ruleSetId     String
  ruleSet       RuleSet @relation(fields: [ruleSetId], references: [id], onDelete: Cascade)
  versionNumber Int     @default(autoincrement())
  name          String?
  description   String?

  rules Json // Rule definitions (DSL)

  status      RuleStatus @default(DRAFT)
  activatedAt DateTime?

  activatedById String?
  activatedBy   User?   @relation("RuleSetActivatedBy", fields: [activatedById], references: [id], onDelete: SetNull)
  createdById   String
  createdBy     User    @relation("RuleSetCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  scoreRuns ScoreRun[]

  @@index([ruleSetId, status])
  @@index([activatedAt])
}

enum RuleStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

model ScoreRun {
  id                 String              @id @default(uuid())
  tenantId           String
  tenant             Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parameterVersionId String
  parameterVersion   ParameterSetVersion @relation(fields: [parameterVersionId], references: [id], onDelete: Restrict)
  ruleSetVersionId   String?
  ruleSetVersion     RuleSetVersion?     @relation(fields: [ruleSetVersionId], references: [id], onDelete: Restrict)

  runType ScoreRunType
  status  ScoreRunStatus @default(PENDING)

  // Date range for this run
  periodStart DateTime?
  periodEnd   DateTime?

  // Stats
  reviewsProcessed Int @default(0)
  themesProcessed  Int @default(0)

  startedAt    DateTime?
  completedAt  DateTime?
  durationMs   Int?
  errorMessage String?

  triggeredById String?
  triggeredBy   User?   @relation(fields: [triggeredById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  reviewScores ReviewScore[]
  themeScores  ThemeScore[]
  fixScores    FixScore[]

  @@index([tenantId, createdAt])
  @@index([tenantId, periodStart, periodEnd])
  @@index([status])
}

enum ScoreRunType {
  SCHEDULED
  MANUAL
  RECALCULATION
  PARAMETER_CHANGE
}

enum ScoreRunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

model ReviewScore {
  id         String   @id @default(uuid())
  reviewId   String
  review     Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  scoreRunId String
  scoreRun   ScoreRun @relation(fields: [scoreRunId], references: [id], onDelete: Cascade)

  // Computed values
  baseSentiment    Float // S_r: [-1, +1]
  timeWeight       Float // W_time: (0, 1]
  sourceWeight     Float // W_source: [0.6, 1.4]
  engagementWeight Float // W_engagement: [1, cap]
  confidenceWeight Float // W_confidence: [0, 1]
  weightedImpact   Float // W_r: final score

  components Json // Full breakdown for audit

  createdAt DateTime @default(now())

  @@unique([reviewId, scoreRunId])
  @@index([scoreRunId])
}

model ThemeScore {
  id         String   @id @default(uuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  themeId    String
  theme      Theme    @relation(fields: [themeId], references: [id], onDelete: Cascade)
  scoreRunId String
  scoreRun   ScoreRun @relation(fields: [scoreRunId], references: [id], onDelete: Cascade)

  periodStart DateTime
  periodEnd   DateTime

  mentionCount  Int
  positiveCount Int
  neutralCount  Int
  negativeCount Int

  sumWeightedImpact    Float // ΣW_r
  sumAbsWeightedImpact Float // Σ|W_r|

  themeSentiment Float // S_theme: [-1, +1]
  themeScore010  Float // Score 0-10
  severity       Float // Severity ranking

  trendDirection TrendDirection?
  trendMagnitude Float? // How much it changed

  createdAt DateTime @default(now())

  @@unique([themeId, scoreRunId])
  @@index([tenantId, scoreRunId])
  @@index([tenantId, periodStart, periodEnd])
  @@index([severity(sort: Desc)])
}

enum TrendDirection {
  IMPROVING
  STABLE
  DECLINING
}

model FixScore {
  id         String    @id @default(uuid())
  tenantId   String
  tenant     Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  themeId    String
  theme      Theme     @relation(fields: [themeId], references: [id], onDelete: Cascade)
  taskId     String?
  task       Task?     @relation(fields: [taskId], references: [id], onDelete: SetNull)
  scoreRunId String
  scoreRun   ScoreRun  @relation(fields: [scoreRunId], references: [id], onDelete: Cascade)

  baselineScore Float // S_before
  currentScore  Float // S_after
  deltaS        Float // ΔS: [-2, +2]

  reviewCountPre  Int
  reviewCountPost Int

  confidence      Float // [0, 1]
  confidenceLevel ConfidenceLevel

  fixScore Float // FixScore formula result

  measurementStart DateTime
  measurementEnd   DateTime

  createdAt DateTime @default(now())

  @@index([tenantId, themeId])
  @@index([tenantId, measurementStart, measurementEnd])
  @@index([taskId])
}

enum ConfidenceLevel {
  INSUFFICIENT
  LOW
  MEDIUM
  HIGH
}

// ============================================================
// RECOMMENDATIONS & TASKS
// ============================================================

model Recommendation {
  id       String  @id @default(uuid())
  tenantId String
  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  themeId  String?
  theme    Theme?  @relation(fields: [themeId], references: [id], onDelete: SetNull)

  severity RecommendationSeverity
  status   RecommendationStatus   @default(OPEN)
  category RecommendationCategory @default(IMPROVEMENT)

  title             String
  description       String?
  suggestedActions  Json     @default("[]")
  evidenceReviewIds String[] @default([])
  estimatedImpact   String?

  // Auto-generated metadata
  triggerReason    String?
  triggerThreshold Float?
  autoGenerated    Boolean @default(false)

  resolvedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tasks Task[]

  @@index([tenantId, status])
  @@index([tenantId, createdAt])
  @@index([severity])
  @@index([category])
}

enum RecommendationSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum RecommendationStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  DISMISSED
}

enum RecommendationCategory {
  URGENT_ISSUE
  IMPROVEMENT
  OPPORTUNITY
  MAINTENANCE
}

model Task {
  id               String          @id @default(uuid())
  tenantId         String
  tenant           Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recommendationId String?
  recommendation   Recommendation? @relation(fields: [recommendationId], references: [id], onDelete: SetNull)
  themeId          String?
  theme            Theme?          @relation(fields: [themeId], references: [id], onDelete: SetNull)

  title       String
  description String?
  notes       String?

  priority TaskPriority @default(MEDIUM)
  status   TaskStatus   @default(PENDING)

  assignedToId String?
  assignedTo   User?   @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  dueDate     DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  impactNotes String?

  createdById String
  createdBy   User   @relation("CreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fixScores FixScore[]

  @@index([tenantId, status])
  @@index([tenantId, dueDate])
  @@index([tenantId, createdAt])
  @@index([assignedToId])
  @@index([priority])
}

enum TaskPriority {
  URGENT
  HIGH
  MEDIUM
  LOW
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// ============================================================
// AUDIT LOG
// ============================================================

model AuditLog {
  id String @id @default(uuid())

  actorId    String
  actor      User     @relation(fields: [actorId], references: [id], onDelete: Restrict)
  actorEmail String
  actorRole  UserRole

  // What happened
  action       AuditAction
  resourceType String
  resourceId   String?

  // Context
  tenantId       String?
  organizationId String?

  // Change details
  oldValue Json?
  newValue Json?
  metadata Json? // Additional context

  // Request info
  ipAddress String?
  userAgent String?
  requestId String?

  createdAt DateTime @default(now())

  @@index([actorId])
  @@index([action])
  @@index([resourceType, resourceId])
  @@index([tenantId, createdAt])
  @@index([organizationId, createdAt])
  @@index([createdAt])
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  EXPORT
  IMPORT
  ACTIVATE
  DEACTIVATE
  TRIGGER
  ACCESS
}
